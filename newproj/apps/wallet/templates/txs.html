{% extends "layout.html" %}
{% block content %}
<!-- Loading overlay -->
<div id="loader" class="fixed inset-0 bg-black/95 z-50 flex items-center justify-center">
  <div class="w-12 h-12 border-4 border-yellow-500 border-t-transparent rounded-full animate-spin"></div>
</div>

<div class="max-w-7xl mx-auto card p-6" x-data="txsPage('{{ account_address or '' }}')" x-init="$nextTick(()=>document.getElementById('loader')?.classList.add('hidden'))">
  <h1 class="text-2xl font-extrabold text-yellow-400 mb-4">Transactions</h1>

  <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
    <section class="lg:col-span-2">
      <div class="card p-4">
        <div class="flex items-center justify-between">
          <h2 class="text-yellow-400 text-xl font-bold mb-3">History</h2>
          <div class="text-sm text-gray-300"><span class="mr-2">Address:</span><span class="mono break-all ml-2">{{ account_address or '-' }}</span></div>
        </div>
        <div class="overflow-x-auto">
          <table class="min-w-full table-fixed">
            <thead>
              <tr class="text-left text-sm text-gray-300">
                <th class="py-2 pr-4 w-28">When</th>
                <th class="py-2 pr-4 w-24">Type</th>
                <th class="py-2 pr-4 w-32">Amount</th>
                <th class="py-2 pr-4 w-24">Fee</th>
                <th class="py-2 pr-4 w-36">Status</th>
                <th class="py-2 pr-4">Txid</th>
              </tr>
            </thead>
            <tbody class="text-sm">
              <template x-for="t in rows" :key="t.txid">
                <tr class="border-t border-yellow-900/30">
                  <td class="py-2 pr-4" x-text="t.when"></td>
                  <td class="py-2 pr-4">
                    <span class="px-2 py-1 rounded text-xs" :class="t.kind==='reward' ? 'bg-yellow-700/30 border border-yellow-600/50' : (t.kind==='incoming' ? 'bg-green-700/30 border border-green-600/50' : (t.kind==='outgoing' ? 'bg-black/30 border border-yellow-900/40' : 'bg-black/30 border border-yellow-900/40'))">
                      <span x-text="t.kind"></span>
                    </span>
                  </td>
                  <td class="py-2 pr-4" x-text="(t.amount ?? 0).toFixed(6) + ' SMELLY'"></td>
                  <td class="py-2 pr-4" x-text="(t.fee ?? 0).toFixed(6)"></td>
                  <td class="py-2 pr-4">
                    <template x-if="t.confirms >= 0">
                      <span class="px-2 py-1 rounded text-xs bg-green-700/30 border border-green-600/50" x-text="t.confirms + ' conf'"></span>
                    </template>
                    <template x-if="t.confirms < 0">
                      <span class="px-2 py-1 rounded text-xs bg-yellow-700/30 border border-yellow-600/50">mempool</span>
                    </template>
                  </td>
                  <td class="py-2 pr-4 mono whitespace-normal break-words" x-text="t.txid"></td>
                </tr>
              </template>
              <tr x-show="rows.length===0">
                <td class="py-3 text-gray-400" colspan="6">No transactions yet.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <aside>
      <div class="card p-4">
        <h2 class="text-yellow-400 text-xl font-bold mb-3">Summary</h2>
        <div class="text-sm text-gray-300">Total Rewards</div>
        <div class="text-2xl font-extrabold"><span x-text="totalRewards.toFixed(6)"></span> <span class="text-yellow-400">SMELLY</span></div>
        <div class="mt-2 text-sm text-gray-300">Pending (mempool)</div>
        <div class="text-lg font-bold"><span x-text="pendingCount"></span> <span class="text-yellow-400">txs</span></div>
      </div>
    </aside>
  </div>
</div>

<script>
function txsPage(addr) {
  return {
    rows: [],
    totalRewards: 0.0,
    pendingCount: 0,
    async init() {
      await this.refresh();
      setInterval(()=>this.refresh(), 10000);
    },
    async refresh() {
      try {
        const heightJson = await fetch('/api/v1/node/height').then(r=>r.json()).catch(()=>({height:-1}));
        const height = typeof heightJson.height === 'number' ? heightJson.height : -1;

        const parts = [];

        // Rewards for this address (coinbase income)
        if (addr) {
          const rewards = await this.fetchRewards(addr);
          let total = 0;
          for (const r of rewards) {
            total += (r.amount || 0);
            const confirms = height >= 0 && typeof r.block_height === 'number' ? Math.max(0, height - r.block_height + 1) : 0;
            parts.push({
              when: 'height ' + (r.block_height ?? '?'),
              kind: 'reward',
              amount: r.amount || 0,
              fee: 0,
              confirms,
              txid: r.txid || ''
            });
          }
          this.totalRewards = total;
        }

        // Pending mempool transactions that involve this address (basic demo filter)
        const mem = await this.fetchMempool(addr);
        const pending = mem.map(m => ({
          when: new Date(m.added_ms || 0).toLocaleString(),
          kind: (m.to_addr === addr ? 'incoming' : (m.from_addr === addr ? 'outgoing' : 'mempool')),
          amount: m.amount || 0,
          fee: m.fee || 0,
          confirms: -1,
          txid: m.txid || ''
        }));
        this.pendingCount = pending.length;

        // Basic outgoing/incoming chain transactions would be added here when we implement signed sends and block inclusion.

        // Merge and sort (rewards by height desc, then pending newest first)
        parts.sort((a,b) => {
          // pending first? Choose: show confirmed (rewards) first:
          if (a.confirms === -1 && b.confirms !== -1) return 1;
          if (b.confirms === -1 && a.confirms !== -1) return -1;
          // fallback by when: parse height digits if present
          const ah = parseInt(String(a.when).replace(/\D/g,'')) || 0;
          const bh = parseInt(String(b.when).replace(/\D/g,'')) || 0;
          return bh - ah;
        });
        // Append pending last
        const pendingLast = pending.sort((a,b)=>(b.added_ms||0)-(a.added_ms||0));
        this.rows = parts.concat(pendingLast);
      } catch(e) {
        this.rows = [];
        this.totalRewards = 0.0;
        this.pendingCount = 0;
      }
    },
    async fetchRewards(address) {
      // Explorer doesn't expose address reward API; use wallet backend data indirectly:
      // We get recent rewards by scanning rewards for the address via a small helper endpoint in future.
      // For now, pull from /api/v1/address/<addr>/balance which doesn't include per-reward height hash.
      // To get heights, we approximate using /block headers if needed. Here we return simplified objects.
      try {
        const b = await fetch('/api/v1/address/' + address + '/balance').then(r=>r.json());
        // We canâ€™t get per-reward height from this endpoint; return minimal rows using txid only.
        // As an enhancement, add a dedicated /api/v1/address/<addr>/rewards endpoint.
        // For UX now, show rewards as individual entries with unknown height.
        return (b.rewards || []).map(x => ({
          amount: x.amount || 0,
          txid: x.txid || '',
          block_height: x.height ?? undefined
        }));
      } catch (e) {
        return [];
      }
    },
    async fetchMempool(addr) {
      try {
        const res = await fetch('/api/v1/mempool?addr=' + encodeURIComponent(addr||''));
        if (!res.ok) return [];
        return await res.json();
      } catch (e) {
        return [];
      }
    }
  }
}
</script>
{% endblock %}
